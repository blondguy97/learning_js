'use strict';

let testObj = new Object(); // Один из возможных способов создать объект, но лучше использовать более классический способ

let options = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red',
        p: {
            me: 'jake'
        }
    }
};





console.log(options.name); // test

delete options.name; // Таким действием мы можем удалить любое ключ-значение в объекте

console.log(options); // name: 'test' уже нету, оно удалено



for (let key in options) {
    console.log(`Свойство ${key} имеет значение ${options[key]}`);
}

/* Порой нужно перебрать объект, для такого существует цикл for in. Здесь переменной для перебора ключей объекта options, выбрано слово key (но можно и любое другое выбрать, но часто называют именно словом key) слова in options, означают что мы будет копаться В объекте options, то есть key in options, перебор ключей в объекте options. А в фигурных скобках мы уже задаем блок кода в котором мы говорим что делать с этими перебираемыми ключами, в данном случсе в скобках мы пишем что свойство *переменная key* имеет значение, а далее мы опять пишем переменную в которой указываем собственно сам объект options а в квадратных скобках пишем опять key, то есть уже это не ключ, а значение в объекте options
 */

/* 
Здесь все вывелось в виде строк, но одно из значений объекта options, является также объектом, и его перебор for in перебрать не смог,
вывел только "Свойство colors имеет значение [object Object]" Когда js на такое натыкается, он не может такое значение как вложенный объект, превратить в строку
[object Object] это не является ошибкой, это просто строковое представление объекта
Но перебрать объект полностью, включая и вложенные объекте, можно, для этого есть несколько способов, один из их это применить условие, в котором будет уточнятся что если ключ такого-то объекта является тоже объектом, то будет выполнятся второй цикл, уже с перебором вложенного объекта. Подробнее ниже
 */

for (let key in options) {
    if (typeof (options[key] === 'object')) {
        for (let i in options[key]) {
            console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
        }
    } else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
    }
}

/* теперь все работает нормально, перебирается и объект внутри объекта тоже.
 console.log(`Свойство ${i} имеет значение ${options[key][i]}`); 
 Если это слишком мозговзрывающая конструкция, ниже более простой пример
 */

console.log(options['colors']['border']);
/* black. То есть это как бы двойной доступ,
сначала к объекту внутри объекта, а затем уже к его свойству и мы получаем значение black из свойства border */



/*  Порой нам нужет счетчик для того чтобы узнать сколько свойств (или методов) находится в объекте, классического свойства lenght(длины) у объектов нет, поэтому часто используется такой способ. */


console.log(Object.keys(options));

/* метод keys объекта Object принимает в скобки какой-либо объект и создает массив где все элементы это ключи переданного в скобки объекта. Вспоминаем, что как у строк, так и у массивов есть свойство length, то есть можно узнать длину. А раз этот метод создал массив, мы можем добавить ему свойство length и узнать сколько элементов находится в объекте*/

console.log(Object.keys(options).length); // 4. То есть столько, сколько элементов в объекте


let options_2 = {
    name: 'test',
    width: 1024,
    height: 1024,
    colors: {
        border: 'black',
        bg: 'red'
    },
    makeTest: function () {
        console.log('Выпонился блок кода в методе makeTest который находится в объекте options_2');
    }
};

/* Метод makeTest в объекте options_2, это функция которая может что-то выполнять, то есть методы объектов мы можем создавать самостоятельно*/


options_2.makeTest(); // Выпонился блок кода в методе makeTest который находится в объекте options_2

/* Деструризация объектов (такое возможно и для массивов)*/


const {
    width
} = options_2;

const {
    bg
} = options_2.colors; // вытаскиваем свойство bg из объекта colors который находится в объекте options_2

console.log(width); // 1024
console.log(bg); // red




/* И ПОМНИ, ВСЕ В ДЖАВАСКРИПТ ЯВЛЯЕТСЯ ОБЪЕКТОМ И ВСЕ ИДЕТ ОТ ОБЪЕКТА
ИМЕННО ПОЭТОМУ У СТРОК ПРИ ВЫЗОВЕ КАКОГО-ТО МЕТОДА НА НИХ ПОЯВЛЯЮТСЯ ФУНКЦИИ КОТОРЫХ НЕ ДОЛЖНО БЫТЬ, ВЕДЬ ОНИ ПО ИДЕЕ ПРИМИТИВЫ */



/*

1) Напишите функцию showFamily, которая будет принимать в себя массив строк и возвращать сообщение в нужном формате.

showFamily(family) => 'Семья состоит из: Peter Ann Alex Linda'

Имена подставляются автоматически из массива.Если массив пустой, то выводится сообщение 'Семья пуста'

*/

const family = ['me', 'she'];

function showFamily(arr) {
    let str = '';

    if (arr.length === 0) {
        str = str + 'Семья пуста';
    } else {
        str = str + `Семья состоит из: `;
    }

    arr.forEach(function (item) {
        str = `${str}${item.toUpperCase()} `;

    });



    return str;
}


console.log(showFamily(family));






/* 


Создайте метод showAgeAndLangs внутри объекта personalPlanPeter.При его вызове метод будет принимать в себя объект и возвращать строку в нужном виде.

Пример:

    personalPlanPeter.showAgeAndLangs(personalPlanPeter) => 'Мне 29 и я владею языками: RU ENG'

Заметьте, что возраст и языки подставляются автоматически из объекта, а языки всегда в верхнем регистре(большими буквами).Если данные в объекте поменяются, то и сообщение тоже изменится.

P.S.Дальше по курсу мы научимся удобно обращаться из метода к самому объекту, в котором он расположен.Но пока делаем это менее удобным способом)


*/


const personalPlanPeter = {
    name: "Peter",
    age: "29",
    skills: {
        languages: ['ru', 'eng'],
        programmingLangs: {
            js: '20%',
            php: '10%'
        },
        exp: '1 month'
    },
    showAgeAndLangs: function (plan) {


        let {
            age
        } = plan;

        let {
            languages
        } = plan.skills;

        let str = `Мне ${age} лет и я владею языками: `;

        languages.forEach(function (lang) {
            str = str + lang.toUpperCase() + ' ';
        });

        return str;
    }
};


console.log(personalPlanPeter.showAgeAndLangs(personalPlanPeter));